Looking at both schemas, I agree that since each item has a one-to-one relationship with a customer, we can simplify by adding a customerId directly to the item table rather than using a separate itemOwners table. This would be cleaner and more efficient.
Here's how I would implement the item-related tables in your current schema:

// ... existing code ...

// Add these enums
export const packingType = pgEnum("packing_type", ['SACK', 'PALLET', 'CARTON', 'OTHER', 'NONE'])
export const movementType = pgEnum("movement_type", ['IN', 'OUT'])

// Item table
export const item = pgTable("item", {
    itemId: uuid("item_id").defaultRandom().primaryKey().notNull(),
    itemNumber: serial("item_number").notNull(),
    
    itemName: varchar("item_name").notNull(),
    itemType: varchar("item_type", { length: 50 }),
    itemBrand: varchar("item_brand", { length: 100 }),
    itemModel: varchar("item_model", { length: 100 }),
    itemBarcode: varchar("item_barcode", { length: 100 }).unique(),
    itemCountryOfOrigin: varchar("item_country_of_origin", { length: 100 }),
    
    dimensions: json("dimensions"),
    weightGrams: integer("weight_grams"),
    
    customerId: uuid("customer_id")
        .notNull()
        .references(() => customers.customerId, { onDelete: "restrict" }),
    
    notes: text(),
    createdBy: uuid("created_by")
        .notNull()
        .references(() => users.userId, { onDelete: "restrict" }),
    
    createdAt: timestamp("created_at", { withTimezone: true }).default(sql`CURRENT_TIMESTAMP`).notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true }).$onUpdate(() => sql`CURRENT_TIMESTAMP`)
});

// Add these types
export type Item = typeof item.$inferSelect;
export type InsertItem = typeof item.$inferInsert;


Key changes and reasoning:
Removed the itemOwners table and added customerId directly to item table since it's a one-to-one relationship
Kept most of the original fields but updated the syntax to match your current schema style
Added proper references to customers and users tables
Used the same timestamp pattern you're using in your current schema
Added proper types exports
Would you like me to also implement the related inventory and transaction tables? They would be useful if you need to track item movements and stock levels.

Let's analyze the inventory management requirements and design a clean solution.
Key Requirements (typical for warehouse management):
Track item quantities across locations
Record all movements (in/out)
Maintain history for auditing
Handle multiple warehouse locations
Ensure data consistency
Let's analyze the current approach and potential improvements:
Current Structure (from OLD schema):

// Three related tables:
1. inventory (tracks current quantities per location)
2. itemTransactions (records all movements)
3. inventoryLocation (stores warehouse locations)

Potential Approaches:
Current Approach (with separate inventory table)
Pros:
Quick quantity lookups
Clear separation of concerns
Cons:
Need to maintain consistency between inventory and transactions
Redundant data (quantity can be calculated from transactions)
Transaction-Only Approach
Pros:
Single source of truth
No data redundancy
Complete audit trail
Cons:
Need to sum transactions to get current quantity
Could be slower for quantity lookups
Hybrid Approach (Recommended)

// Locations
export const locations = pgTable("locations", {
    locationId: uuid("location_id").defaultRandom().primaryKey(),
    locationName: text("location_name").notNull(),
    locationCode: text("location_code").notNull(),
    notes: text(),
    createdAt: timestamp("created_at", { withTimezone: true }).default(sql`CURRENT_TIMESTAMP`).notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true }).$onUpdate(() => sql`CURRENT_TIMESTAMP`)
});

// Current Stock (Materialized View or regularly updated table)
export const itemStock = pgTable("item_stock", {
    itemId: uuid("item_id")
        .references(() => item.itemId)
        .notNull(),
    locationId: uuid("location_id")
        .references(() => locations.locationId)
        .notNull(),
    currentQuantity: integer("current_quantity").notNull().default(0),
    lastUpdated: timestamp("last_updated", { withTimezone: true })
        .default(sql`CURRENT_TIMESTAMP`)
        .notNull(),
}, (table) => ({
    pk: primaryKey({ columns: [table.itemId, table.locationId] }),
    quantityCheck: check("quantity_check", sql`current_quantity >= 0`)
}));

// Stock Movements
export const stockMovements = pgTable("stock_movements", {
    movementId: uuid("movement_id").defaultRandom().primaryKey(),
    itemId: uuid("item_id")
        .references(() => item.itemId)
        .notNull(),
    locationId: uuid("location_id")
        .references(() => locations.locationId)
        .notNull(),
    movementType: movementType("movement_type").notNull(),
    quantity: integer("quantity").notNull(),
    
    // Reference fields
    referenceType: text("reference_type"), // e.g., "ORDER", "ADJUSTMENT", "COUNT"
    referenceId: uuid("reference_id"),     // ID of the related record
    
    notes: text(),
    createdBy: uuid("created_by")
        .references(() => users.userId)
        .notNull(),
    createdAt: timestamp("created_at", { withTimezone: true })
        .default(sql`CURRENT_TIMESTAMP`)
        .notNull(),
});

Recommended Approach Benefits:
itemStock provides quick access to current quantities
stockMovements maintains complete history
locations keeps warehouse organization simple
The schema supports:
Multiple locations
Full audit trail
Quick quantity lookups
Various movement types (orders, adjustments, counts)
Data consistency through constraints
Key Improvements:
Simplified location structure
Combined movement tracking into single table
Added reference fields for linking to orders or other sources
Maintained data integrity through foreign keys and checks
Would you like me to explain any part in more detail or discuss specific use cases this schema would handle?

Scenario 1: Receiving New Inventory
When new items arrive at the warehouse:
// 1. Create stock movement record
await db.insert(stockMovements).values({
    movementId: generateUUID(),
    itemId: "item123",
    locationId: "warehouse1",
    movementType: "IN",
    quantity: 100,
    referenceType: "PURCHASE_ORDER",
    referenceId: "po123",
    notes: "Initial stock receipt",
    createdBy: "user123"
});

// 2. itemStock gets updated (via trigger or application logic)
// FROM: 0 → TO: 100

Scenario 2: Customer Order Fulfillment
When fulfilling a customer's order:

// 1. Check if enough stock exists
const stock = await db.query.itemStock.findFirst({
    where: eq(itemStock.itemId, "item123")
});
if (stock.currentQuantity < orderQuantity) {
    throw new Error("Insufficient stock");
}

// 2. Record the movement
await db.insert(stockMovements).values({
    movementId: generateUUID(),
    itemId: "item123",
    locationId: "warehouse1",
    movementType: "OUT",
    quantity: 50,
    referenceType: "CUSTOMER_ORDER",
    referenceId: "order123",
    createdBy: "user123"
});

// 3. itemStock gets updated
// FROM: 100 → TO: 50

Scenario 3: Moving Stock Between Locations
When transferring items between warehouses:

// 1. Record movement out from source location
await db.insert(stockMovements).values({
    movementId: generateUUID(),
    itemId: "item123",
    locationId: "warehouse1",
    movementType: "OUT",
    quantity: 25,
    referenceType: "TRANSFER",
    referenceId: "transfer123",
    createdBy: "user123"
});

// 2. Record movement in to destination location
await db.insert(stockMovements).values({
    movementId: generateUUID(),
    itemId: "item123",
    locationId: "warehouse2",
    movementType: "IN",
    quantity: 25,
    referenceType: "TRANSFER",
    referenceId: "transfer123",
    createdBy: "user123"
});

// 3. itemStock gets updated for both locations
// warehouse1: 50 → 25
// warehouse2: 0 → 25

Scenario 4: Inventory Count/Adjustment
When performing inventory counts and adjustments:

// 1. Record adjustment (if count shows 22 items instead of 25)
await db.insert(stockMovements).values({
    movementId: generateUUID(),
    itemId: "item123",
    locationId: "warehouse2",
    movementType: "OUT",
    quantity: 3,
    referenceType: "INVENTORY_COUNT",
    referenceId: "count123",
    notes: "Adjustment after physical count",
    createdBy: "user123"
});

// 2. itemStock gets updated
// FROM: 25 → TO: 22

Scenario 5: Audit Trail Query
When needing to review item history:

// Query all movements for an item
const itemHistory = await db.query.stockMovements.findMany({
    where: eq(stockMovements.itemId, "item123"),
    orderBy: desc(stockMovements.createdAt),
    include: {
        location: true,
        createdByUser: true
    }
});

// Query current stock across all locations
const itemStock = await db.query.itemStock.findMany({
    where: eq(itemStock.itemId, "item123"),
    include: {
        location: true
    }
});

Additional Considerations:
Data Consistency
Use transactions when multiple operations are needed
Implement triggers or application logic to keep itemStock in sync
Add constraints to prevent negative stock
Performance
itemStock provides quick access to current quantities
Index frequently queried fields
Consider partitioning stockMovements by date for large datasets
Business Rules
Add check constraints for valid quantities
Implement location-specific rules
Add status fields if needed (e.g., for quarantine)
Would you like me to elaborate on any of these scenarios or discuss additional use cases?


ok before implementing this we also need to consider orders, as from our old schema @OLD.schema.ts and how that will tie in with your proposed implementation

Let's analyze how orders integrate with our inventory management system. From the OLD schema, we had:
orders table (with various types: CUSTOMER_ORDER, MANUAL_ADJUSTMENT, INVENTORY_COUNT, TRANSFER_LOCATION)
orderItems linking orders to items
itemTransactions recording the actual movements
Let's design an integrated solution:

// Enums
export const orderStatus = pgEnum("order_status", [
    'PENDING',
    'PROCESSING',
    'READY',
    'COMPLETED',
    'CANCELLED'
]);

export const orderType = pgEnum("order_type", [
    'CUSTOMER_ORDER',
    'MANUAL_ADJUSTMENT',
    'INVENTORY_COUNT',
    'TRANSFER_LOCATION'
]);

export const deliveryMethod = pgEnum("delivery_method", [
    'PICKUP',
    'DELIVERY'
]);

// Orders
export const orders = pgTable("orders", {
    orderId: uuid("order_id").defaultRandom().primaryKey(),
    orderNumber: serial("order_number").notNull(),
    
    // Who created and owns the order
    createdBy: uuid("created_by")
        .references(() => users.userId)
        .notNull(),
    customerId: uuid("customer_id")
        .references(() => customers.customerId)
        .notNull(),
    
    // Order details
    orderType: orderType("order_type").notNull(),
    status: orderStatus("status").default('PENDING').notNull(),
    deliveryMethod: deliveryMethod("delivery_method").notNull(),
    
    // For transfers, specify source and destination
    sourceLocationId: uuid("source_location_id")
        .references(() => locations.locationId),
    destinationLocationId: uuid("destination_location_id")
        .references(() => locations.locationId),
    
    notes: text(),
    
    // Timestamps
    fulfilledAt: timestamp("fulfilled_at", { withTimezone: true }),
    createdAt: timestamp("created_at", { withTimezone: true })
        .default(sql`CURRENT_TIMESTAMP`)
        .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
        .$onUpdate(() => sql`CURRENT_TIMESTAMP`),
}, (table) => ({
    // Ensure either both or neither location is set for transfers
    transferCheck: check(
        "valid_transfer_locations",
        sql`(order_type = 'TRANSFER_LOCATION' AND source_location_id IS NOT NULL AND destination_location_id IS NOT NULL) OR
            (order_type != 'TRANSFER_LOCATION' AND source_location_id IS NULL AND destination_location_id IS NULL)`
    )
}));

// Order Items
export const orderItems = pgTable("order_items", {
    orderItemId: uuid("order_item_id").defaultRandom().primaryKey(),
    orderId: uuid("order_id")
        .references(() => orders.orderId, { onDelete: "cascade" })
        .notNull(),
    itemId: uuid("item_id")
        .references(() => item.itemId)
        .notNull(),
    quantity: integer("quantity").notNull(),
    locationId: uuid("location_id")
        .references(() => locations.locationId)
        .notNull(),
    status: orderStatus("status").default('PENDING').notNull(),
    
    createdAt: timestamp("created_at", { withTimezone: true })
        .default(sql`CURRENT_TIMESTAMP`)
        .notNull(),
    updatedAt: timestamp("updated_at", { withTimezone: true })
        .$onUpdate(() => sql`CURRENT_TIMESTAMP`),
}, (table) => ({
    quantityCheck: check("positive_quantity", sql`quantity > 0`)
}));

Let's see how this integrates with our previous inventory management in some scenarios:

Scenario 1: Creating a Customer Order

// 1. Create the order
const order = await db.insert(orders).values({
    createdBy: userId,
    customerId: customerId,
    orderType: 'CUSTOMER_ORDER',
    deliveryMethod: 'PICKUP',
    status: 'PENDING'
}).returning();

// 2. Add order items
await db.insert(orderItems).values({
    orderId: order.orderId,
    itemId: "item123",
    quantity: 5,
    locationId: "warehouse1",
    status: 'PENDING'
});

Scenario 2: Fulfilling a Customer Order
// 1. Check stock availability
const stock = await db.query.itemStock.findFirst({
    where: and(
        eq(itemStock.itemId, "item123"),
        eq(itemStock.locationId, "warehouse1")
    )
});

// 2. Record the movement
await db.transaction(async (tx) => {
    // Update order status
    await tx.update(orders)
        .set({ status: 'COMPLETED', fulfilledAt: new Date() })
        .where(eq(orders.orderId, "order123"));
    
    // Record stock movement
    await tx.insert(stockMovements).values({
        itemId: "item123",
        locationId: "warehouse1",
        movementType: "OUT",
        quantity: 5,
        referenceType: "CUSTOMER_ORDER",
        referenceId: "order123",
        createdBy: userId
    });
});

Scenario 3: Transfer Order Between Locations
// 1. Create transfer order
const transfer = await db.insert(orders).values({
    createdBy: userId,
    customerId: customerId,
    orderType: 'TRANSFER_LOCATION',
    status: 'PENDING',
    sourceLocationId: "warehouse1",
    destinationLocationId: "warehouse2"
}).returning();

// 2. Process transfer
await db.transaction(async (tx) => {
    // Record movement out from source
    await tx.insert(stockMovements).values({
        itemId: "item123",
        locationId: "warehouse1",
        movementType: "OUT",
        quantity: 10,
        referenceType: "TRANSFER",
        referenceId: transfer.orderId,
        createdBy: userId
    });

    // Record movement in to destination
    await tx.insert(stockMovements).values({
        itemId: "item123",
        locationId: "warehouse2",
        movementType: "IN",
        quantity: 10,
        referenceType: "TRANSFER",
        referenceId: transfer.orderId,
        createdBy: userId
    });

    // Update order status
    await tx.update(orders)
        .set({ status: 'COMPLETED' })
        .where(eq(orders.orderId, transfer.orderId));
});

Key improvements over the OLD schema:
Simplified order structure while maintaining functionality
Better integration between orders and inventory movements
Added proper constraints and checks
Maintained full audit trail
Support for all order types with appropriate validations
Would you like me to explain any part in more detail or show more scenarios?